<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tutorial Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Tutorial de Rust realizado para la clase de Lenguajes de Programación 2022-1">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="presentacion.html"><strong aria-hidden="true">1.</strong> Presentación</a></li><li class="chapter-item expanded affix "><li class="part-title">Conociendo Rust</li><li class="chapter-item expanded "><a href="conociendo/rust.html"><strong aria-hidden="true">2.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conociendo/rust/historia.html"><strong aria-hidden="true">2.1.</strong> Historia</a></li><li class="chapter-item expanded "><a href="conociendo/rust/caracteristicas.html"><strong aria-hidden="true">2.2.</strong> Características</a></li></ol></li><li class="chapter-item expanded "><a href="conociendo/prueba.html"><strong aria-hidden="true">3.</strong> Prueba Rust</a></li><li class="chapter-item expanded affix "><li class="part-title">Primeros Pasos</li><li class="chapter-item expanded "><a href="primeros_pasos/introduccion.html"><strong aria-hidden="true">4.</strong> Introducción</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primeros_pasos/introduccion/instalacion.html"><strong aria-hidden="true">4.1.</strong> Instalación</a></li><li class="chapter-item expanded "><a href="primeros_pasos/introduccion/hola_mundo.html"><strong aria-hidden="true">4.2.</strong> Hola Mundo</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Tutorial Rust</li><li class="chapter-item expanded "><a href="tutorial/generalidades.html"><strong aria-hidden="true">5.</strong> Generalidades</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/generalidades/variables_mutabilidad.html"><strong aria-hidden="true">5.1.</strong> Variables y mutabilidad</a></li><li class="chapter-item expanded "><a href="tutorial/generalidades/tipos_datos.html"><strong aria-hidden="true">5.2.</strong> Tipos de datos</a></li><li class="chapter-item expanded "><a href="tutorial/generalidades/funciones.html"><strong aria-hidden="true">5.3.</strong> Funciones</a></li><li class="chapter-item expanded "><a href="tutorial/generalidades/comentarios.html"><strong aria-hidden="true">5.4.</strong> Comentarios</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/estructuras.html"><strong aria-hidden="true">6.</strong> Estructuras</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/estructuras/tupla.html"><strong aria-hidden="true">6.1.</strong> Estructuras de Tupla</a></li><li class="chapter-item expanded "><a href="tutorial/estructuras/tipo_unidad.html"><strong aria-hidden="true">6.2.</strong> Estructura Tipo-Unidad</a></li><li class="chapter-item expanded "><a href="tutorial/estructuras/metodos.html"><strong aria-hidden="true">6.3.</strong> Métodos</a></li><li class="chapter-item expanded "><a href="tutorial/estructuras/funciones_asociadas.html"><strong aria-hidden="true">6.4.</strong> Funciones asociadas</a></li><li class="chapter-item expanded "><a href="tutorial/estructuras/enumeraciones.html"><strong aria-hidden="true">6.5.</strong> Enumeraciones</a></li><li class="chapter-item expanded "><a href="tutorial/estructuras/traits.html"><strong aria-hidden="true">6.6.</strong> Traits (Rasgos)</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/concurrencia.html"><strong aria-hidden="true">7.</strong> Concurrencia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/concurrencia/paso_mensajes.html"><strong aria-hidden="true">7.1.</strong> Paso de mensajes</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Bibliografía</li><li class="chapter-item expanded "><a href="bibliografia/referencias.html"><strong aria-hidden="true">8.</strong> Referencias</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tutorial Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cdsaineac/TutorialRust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="presentación"><a class="header" href="#presentación">Presentación</a></h1>
<p><img src="images/RustBanner.jpg" alt="The Rust Banner" /></p>
<p>Este libro ha sido realizado para la clase de Lenguajes de Programación 2022-1, Grupo 1.</p>
<p>En el menú que se encuentra a la izquierda, encontrarán el temario general del tutorial, iniciando con la presentación del lenguaje, su historia, importancia y aplicaciones más importantes.</p>
<p>Posteriormente, indicamos los primeros pasos para desarrollar en Rust tales como su instalación, programas básicos como Hola Mundo y su administrador de paquetes o librerías Cargo. De ahí en adelante, abordamos las generalidades y nociones básicas que el lector debe tener en cuenta para programar en Rust y finalizamos con algunos temas cruciales como las estructuras de datos y la implementación de la concurrencia.</p>
<p>En la última sección se encuentran las referencias usadas para el desarrollo de la presentación y de este libro.</p>
<h2 id="autores"><a class="header" href="#autores">Autores</a></h2>
<p>Nuestro grupo está conformado por:</p>
<ul>
<li>Brayan David León Sanabria</li>
<li>Carlos Augusto Gutiérrez Silva</li>
<li>Cristian David Sainea Céspedes</li>
<li>Diego Felipe Sánchez Medina</li>
</ul>
<h2 id="para-tener-en-cuenta"><a class="header" href="#para-tener-en-cuenta">Para tener en cuenta</a></h2>
<p>Los ejemplos mostrados en el libro se encuentran en celdas de código ejecutables, de esta manera el lector podrá ver los resultados de la ejecución de manera inmediata en el navegador sin necesidad de realizar ninguna instalación adicional.</p>
<p>Las celdas que contienen los ejemplos no son editables, sin embargo, añadimos una sección de libre edición para la libre práctica del lenguaje por parte del lector. Puedes encontrarla <a href="conociendo/prueba.html">aquí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p align="center">
  <img src="conociendo/../images/Rust_Logo400.png" alt="Rust Logo"/>
</p>
<p>Es un lenguaje diseñado para el rendimiento y la seguridad, especialmente la <a href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)">concurrencia segura</a>. Rust es conocido por hacer cumplir la seguridad de la memoria, es decir, que todas las referencias apuntan a una memoria válida, sin requerir el uso de un recolector de basura o el recuento de referencias. La seguridad de la memoria se aplica mediante un &quot;verificador de préstamo&quot;, que rastrea la vida útil del objeto y el alcance variable a medida que las referencias se pasan a través del programa durante la compilación. </p>
<p>Rust es un lenguaje de programación de propósito general, es considerado multiparadigma y puede ser clasificado como:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Concurrent_programming">Concurrente</a></li>
<li><a href="https://en.wikipedia.org/wiki/Functional_programming">Funcional</a></li>
<li><a href="https://en.wikipedia.org/wiki/Generic_programming">Generico</a></li>
<li><a href="https://en.wikipedia.org/wiki/Generic_programming">Imperativo</a></li>
<li><a href="https://en.wikipedia.org/wiki/Structured_programming">Estructurado</a></li>
</ul>
<p>Además se puede utilizar para la programación de sistemas con mecanismos para la gestión de memoria de bajo nivel, pero también ofrece características de alto nivel como la programación funcional.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="historia"><a class="header" href="#historia">Historia</a></h1>
<ul>
<li>Rust comenzó en <strong>2006</strong> como un proyecto paralelo de <a href="https://github.com/graydon">Graydon Hoare</a>, un empleado de Mozilla.</li>
<li>En poco tiempo, Mozilla vio el potencial del nuevo lenguaje y comenzó a patrocinarlo en <strong>2009</strong>, antes de revelarlo al mundo en <strong>2010</strong>.</li>
<li>La primera versión estable de Rust fue lanzada el 15 de mayo de <strong>2015</strong>.</li>
<li>En agosto de <strong>2020</strong>, Mozilla despidió 250 empleados para reestructurar internamente la compañia a causa de la pandemia del Covid-19. Entre ellos, el equipo <a href="https://en.wikipedia.org/wiki/Servo_(software)">Servo</a> (un motor de renderizado web escrito en Rust). Esto creó preocupación sobre el futuro de Rust, pues varios de estos empleados contribuian activamente al lenguaje. </li>
<li>La siguiente semana, el equipo desarollador central de Rust confirmó el impacto que habían causado los despidos al lenguaje, tomando la deicisión de entregar los dominios y la propiedad completa del mismo a la fundación Rust </li>
<li>El 8 de Febrero de 2021 se anunció la creación formal de la <a href="https://en.wikipedia.org/wiki/Rust_Foundation">fundación Rust</a> conformada por AWS, Huawei, Google, Microsoft y Mozilla</li>
</ul>
<p><img src="conociendo/rust/../../images/Rust_Foundation.png" alt="Rust Foundation" /></p>
<ul>
<li>En abril del 2021, Google anunció la compatibilidad con Rust dentro del <a href="https://en.wikipedia.org/wiki/Android_Open_Source_Project">proyecto de código abierto de Android</a>, como alternativa a C/C++</li>
</ul>
<h2 id="origen-del-nombre"><a class="header" href="#origen-del-nombre">Origen del nombre</a></h2>
<p>Una posible fuente del nombre, según Hoare, es el hongo <a href="https://en.wikipedia.org/wiki/Rust_(fungus)">Rust</a>, o en español hongo roya. En varias ocaciones Graydon ha sido cuestionado por el origen de este nombre, quien siempre <a href="https://www.reddit.com/r/rust/comments/27jvdt/internet_archaeology_the_definitive_endall_source/">responde</a> que aunque pueden ser varias las razones que lo llevaron a nombrar el lenguaje de programación de esta manera, la 
principal es que los hongos Rust son sorprendemente <strong>robustos</strong>, son organismos <strong>distribuidos</strong> y pueden alternar entre diferentes anfitriones, como si funcionaran en <strong>paralelo</strong>.</p>
<h2 id="aceptación"><a class="header" href="#aceptación">Aceptación</a></h2>
<p>A pesar de su relativa juventud, Rust ha ascendido constantemente en las filas de los lenguajes de programación populares. De hecho, mientras ocupaba el puesto 33 en julio de 2019, en julio de 2020 había subido al puesto 18 en el Índice de la comunidad de programación de <a href="https://www.tiobe.com/tiobe-index/">TIOBE</a>. Del mismo modo, según la Encuesta de <a href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved">desarrolladores de Stack Overflow</a> , Rust ha sido el lenguaje &quot;más querido&quot; cada año desde 2016 hasta 2022.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="características"><a class="header" href="#características">Características</a></h1>
<h3 id="desempeño"><a class="header" href="#desempeño">Desempeño</a></h3>
<p>Rust es increíblemente rápido y eficiente en cuanto a memoria: sin tiempo de ejecución ni recolector de elementos no utilizados, puede potenciar servicios críticos para el rendimiento, ejecutarse en dispositivos integrados e integrarse fácilmente con otros lenguajes.</p>
<h3 id="fiabilidad"><a class="header" href="#fiabilidad">Fiabilidad</a></h3>
<p>El sistema de tipo enriquecido y el modelo de propiedad de Rust garantizan la seguridad de la memoria y de los subprocesos, lo que le permite eliminar muchas clases de errores en tiempo de compilación.</p>
<h3 id="productividad"><a class="header" href="#productividad">Productividad</a></h3>
<p>Rust tiene una excelente documentación, un compilador amigable con mensajes de error útiles y herramientas de primer nivel: un administrador de paquetes integrado y una herramienta de compilación, soporte inteligente para múltiples editores con autocompletado e inspecciones de tipos, un formateador automático y más.</p>
<h3 id="concurrencia"><a class="header" href="#concurrencia">Concurrencia</a></h3>
<p>Rust maneja muy bien la concurrencia, ya que su modelo de propiedad y la verificación de tipos le permiten asegurarse de que cualquier error que ocurra debido a la concurrencia sea un error de tiempo de compilación y, por lo tanto, permite a los desarrolladores corregir el código mientras trabajan en él, en lugar de trabajar potencialmente. en él después de haber sido enviado a producción.</p>
<p align="center">
  <img src="conociendo/rust/../../images/Rustacean.png" alt="Rustacean Logo"/>
</p><div style="break-before: page; page-break-before: always;"></div><h1 id="prueba-rust"><a class="header" href="#prueba-rust">Prueba Rust</a></h1>
<p>Practica los conceptos del tutorial en esta celda editable!! </p>
<p>\(ᵔᵕᵔ)/</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Usa este editor de prueba de manera libre :D&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducción"><a class="header" href="#introducción">Introducción</a></h1>
<p>En este capítulo, discutiremos:</p>
<ul>
<li><a href="primeros_pasos/./introduccion/instalacion.html">Instalación de Rust en Linux, macOS y Windows</a>
<img src="primeros_pasos/../images/install_rust_banner.png" alt="Install Rust Banner" /></li>
<li><a href="primeros_pasos/./introduccion/hola_mundo.html">Escribir un programa que imprima ¡Hola, mundo!</a>
<img src="primeros_pasos/../images/Rust_hello_world.jpg" alt="Hello World Rust" /></li>
</ul>
<!---
- [Usando cargo, el administrador de paquetes de Rust y el sistema de compilación](./introduccion/hola_cargo.md)
![Cargo Logo](../images/Cargo-Logo-Small.png)
--->
<div style="break-before: page; page-break-before: always;"></div><h1 id="instalación"><a class="header" href="#instalación">Instalación</a></h1>
<p>El primer paso es descargar Rust a través de 'rustup', una herramienta de línea de comandos para administrar versiones de Rust y las herramientas relacionadas.</p>
<blockquote>
<p>Nota: Si prefieres no usar <code>rustup</code> por alguna razón, puedes consultar:
<a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Otros medios de instalación</a> para más opciones.</p>
</blockquote>
<p>A través de los siguientes pasos se explica como instalar la versión estable más reciente del compilador de Rust. Esto garantiza que todos los ejemplos en el libro seguirán compilando con versiones de Rust más nuevas. La salida podría diferir ligeramente debido a que Rust usualmente implementa mensajes de error y avisos para versiones previas.</p>
<h3 id="instalando-rustup-en-linux-o-macos"><a class="header" href="#instalando-rustup-en-linux-o-macos">Instalando <code>rustup</code> en Linux o macOS</a></h3>
<p>Si estás usando Linux o macOS, se debe abrir la terminal e ingresar el siguiente comando:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.3 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Esto descarga un script e inicia la instalación de la herramienta <code>rustup</code>, la cual instala la versión estable más reciente de Rust. Si la instalación es exitosa, aparecerá el siguiente mensaje en consola:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>También necesitará un &quot;Linker&quot;, el cual es un programa que usa Rust para juntar sus salidas compiladas en un solo archivo. Si tienes errores con el Linker, se deberían solucionar instalando un compilador de C, el cual usualmente incluye un Linker. </p>
<h3 id="instalando-rustup-en-windows"><a class="header" href="#instalando-rustup-en-windows">Instalando <code>rustup</code> en Windows</a></h3>
<p>En Windows, ve a <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> y sigue las instrucciones para instalar Rust. En algún punto de la instalación, recibirás un mensaje explicando que también es necesario instalar &quot;C++ build tools&quot; para Visual Studio 2013 o versiones posteriores. Es posible realizar esta instalación siguiendo las instrucciones descritas en el siguiente enlace: <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Build Tools for Visual Studio 2019</a>.</p>
<p>El resto de este libro usa comandos que funcionarán tanto en <em>cmd.exe</em> como en PowerShell</p>
<h3 id="comprobando-actualizando-y-desinstalando"><a class="header" href="#comprobando-actualizando-y-desinstalando">Comprobando, Actualizando y desinstalando</a></h3>
<p>Luego de la instalación, puedes comprobar el funcionamiento correcto de Rust ejecutando el siguiente comando en consola:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>Deberías ver, como respuesta, el número de la versión junto con algunos datos adicionales en el siguiente formato:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Si ves esta información, has instalado Rust satisfactoriamente! En caso contrario, debes verificar que Rust está en la variable de sistema <code>%PATH%</code> o si requieres de ayuda adicional, puedes visitar los foros de ayuda para principiantes que se encuentran en los siguientes enlaces:</p>
<ul>
<li><a href="https://discord.gg/rust-lang">Discord</a> </li>
<li><a href="https://users.rust-lang.org/">Users Rust</a></li>
<li><a href="https://stackoverflow.com/questions/tagged/rust">Rust en stackoverflow</a></li>
</ul>
<p>Posteriormente, puedes actualizar Rust a su última versión a través del comando:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>Finalmente, si requieres desinstalar Rust y <code>rustup</code>, debes ejecutar el siguiente script desde la consola:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hola-mundo"><a class="header" href="#hola-mundo">Hola Mundo</a></h1>
<p>Ya que Rust se ha instalado, podemos iniciar programando el tradicional Hola Mundo como programa de prueba.</p>
<h3 id="escribiendo-y-corriendo-el-primer-programa-de-rust"><a class="header" href="#escribiendo-y-corriendo-el-primer-programa-de-rust">Escribiendo y corriendo el primer programa de Rust</a></h3>
<p>Posterior a la creación del directorio, se debe crear un archivo fuente, al que nombraremos <em>main.rs</em>. Los archivos de Rust siempre terminan con la extensión <em>.rs</em></p>
<p>En el archivo creado, escribiremos el código de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    println!(&quot;Hola, mundo!&quot;);
}
</code></pre></pre>
<p>Prestemos atención a la sintaxis básica del lenguaje.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generalidades"><a class="header" href="#generalidades">Generalidades</a></h1>
<p>Este capítulo cubre conceptos que aparecen en casi todos los lenguajes de programación y cómo funcionan en Rust. Ninguno de los conceptos presentados en este capítulo es exclusivo de Rust, pero los discutiremos en el contexto de Rust y explicaremos las convenciones sobre el uso de estos conceptos.</p>
<blockquote>
<h3 id="palabras-clave"><a class="header" href="#palabras-clave">Palabras clave</a></h3>
<p>El lenguaje Rust tiene un conjunto de palabras clave que están reservadas para uso exclusivo del lenguaje, al igual que en otros lenguajes. Tenga en cuenta que no puede usar estas palabras como nombres de variables o funciones. La mayoría de las palabras clave tienen significados especiales y las usará para realizar varias tareas en sus programas Rust; algunos no tienen una funcionalidad actual asociada con ellos, pero se han reservado para la funcionalidad que podría agregarse a Rust en el futuro. Puede encontrar una lista de las palabras clave en el <a href="https://doc.rust-lang.org/book/appendix-01-keywords.html">Apéndice A</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-y-mutabilidad"><a class="header" href="#variables-y-mutabilidad">Variables y mutabilidad</a></h1>
<p>Por defecto, las variables en Rust son inmutables, lo que quiere decir que una vez que un valor está vinculado a un nombre, no puede cambiar ese valor. Este es uno de los muchos beneficios que da Rust para escribir código de una manera que se aproveche la seguridad y la fácil concurrencia. Sin embargo, aún tiene la opción de hacer que sus variables sean mutables.</p>
<h4 id="ejemplo-declaración-de-variables"><a class="header" href="#ejemplo-declaración-de-variables">Ejemplo declaración de variables</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let x = 5;
    println!(&quot;El valor de x es: {}&quot;, x);
    //x = 6;
    //println!(&quot;El valor de x es: {}&quot;, x);
}
</code></pre></pre>
<h4 id="ejemplo-declaración-de-variables-mutables"><a class="header" href="#ejemplo-declaración-de-variables-mutables">Ejemplo declaración de variables mutables</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let mut x = 5;
    println!(&quot;El valor de x es: {}&quot;, x);
    x = 6;
    println!(&quot;El valor de x es: {}&quot;, x);
}
</code></pre></pre>
<h2 id="constantes"><a class="header" href="#constantes">Constantes</a></h2>
<p>Las constantes también son valores que están vinculados a un nombre y no se les permite cambiar, pero hay algunas diferencias entre constantes y variables.</p>
<ol>
<li>No se permite usar <em>mut</em> </li>
<li>Se debe indicar el tipo de dato al momento de declararla</li>
<li>Se pueden declarar en cualquier ámbito, incluido el ámbito local (alcance)</li>
<li>Solo pueden declararse formalmente, no como resultado de un valor calculado en timpo de ejecución</li>
</ol>
<pre><code class="language-rust  noplayground">const TRES_HORAS_EN_SEGUNDOS: u32 = 60 * 60 * 3;
</code></pre>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>Este término se refiere a cuando una variable se declara con el mismo nombre de una variable previamente creada.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;El valor de x en el alcance interno es: {}&quot;, x);
    }

    println!(&quot;El valor de x es: {}&quot;, x);
}
</code></pre></pre>
<p>Es importante reconocer la diferencia entre mutabilidad y shadowing, debido a que efectivamente estamos creando una nueva variable cuando usamos <em>let</em> nuevamente, y no sobreescribiendo la variable anterior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tipos-de-datos"><a class="header" href="#tipos-de-datos">Tipos de datos</a></h1>
<p>Cada valor en Rust es de un cierto tipo, lo cual le dice a Rust qué tipo de dato se está especificando para que sepa cómo trabajar con esos datos.</p>
<p>Debemos tener en cuenta que Rust es un lenguaje de tipado estático, esto significa que debe conocer los tipos de todas las variables en el momento de la compilación. El compilador <strong>generalmente</strong> puede inferir qué tipo queremos usar en función del valor y cómo lo usamos.</p>
<p>Veremos dos subconjuntos de tipos de datos: escalares y compuestos.</p>
<h2 id="tipos-escalares"><a class="header" href="#tipos-escalares">Tipos escalares</a></h2>
<p>Un tipo escalar representa un valor único. Rust tiene cuatro tipos escalares principales: enteros, números de punto flotante, booleanos y caracteres. </p>
<h3 id="tipos-enteros"><a class="header" href="#tipos-enteros">Tipos enteros</a></h3>
<p>Un número entero es un número sin un componente fraccionario. En Rust es importante indicar el tamaño que este entero ocupará y si lleva signo o no. Las siguientes variantes son validas para usarse en la declaración de un entero:</p>
<table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<h3 id="tipos-de-puntos-flotantes"><a class="header" href="#tipos-de-puntos-flotantes">Tipos de puntos flotantes</a></h3>
<p>Rust también tiene dos tipos primitivos para números de coma flotante. Los tipos de coma flotante de Rust son f32 y f64, que tienen un tamaño de 32 bits y 64 bits, respectivamente. Todos los números de tipo punto flotante tienen signo.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64 por defecto

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>Recordar que, como en muchos otros lenguajes, Rust permite realizar operaciones matemáticas básicas tales como </p>
<ul>
<li>Suma <em>+</em></li>
<li>Resta <em>-</em></li>
<li>Multiplicación <em>*</em></li>
<li>División <em>/</em></li>
<li>Módulo <em>%</em> </li>
</ul>
<h3 id="el-tipo-booleano"><a class="header" href="#el-tipo-booleano">El tipo booleano</a></h3>
<p>Los booleanos tienen un tamaño de un byte. El tipo booleano en Rust se especifica mediante bool</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // con tipado de tipo explícito
}
</code></pre></pre>
<h3 id="el-tipo-caracter"><a class="header" href="#el-tipo-caracter">El tipo caracter</a></h3>
<p><strong>char</strong> de Rust es el tipo alfabético más primitivo del lenguaje:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
}
</code></pre></pre>
<h2 id="tipos-compuestos"><a class="header" href="#tipos-compuestos">Tipos Compuestos</a></h2>
<p>Los tipos compuestos pueden agrupar varios valores en un solo tipo. Rust tiene dos tipos de compuestos primitivos: tuplas y matrices.</p>
<h3 id="el-tipo-de-tupla"><a class="header" href="#el-tipo-de-tupla">El tipo de tupla</a></h3>
<p>Una tupla es una forma general de agrupar una cantidad de valores con una variedad de tipos en un tipo compuesto. Las tuplas tienen una longitud fija: una vez declaradas, no pueden crecer ni reducir su tamaño.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    println!(&quot;El primer valor de la tupla es: {}&quot;, tup.0);
    println!(&quot;El segundo valor de la tupla es: {}&quot;, tup.1);
    println!(&quot;El tercer valor de la tupla es: {}&quot;, tup.2);
}
</code></pre></pre>
<h3 id="el-tipo-arreglo"><a class="header" href="#el-tipo-arreglo">El tipo arreglo</a></h3>
<p>Otra forma de tener una colección de valores múltiples es con una matriz . A diferencia de una tupla, todos los elementos de una matriz deben tener el mismo tipo. A diferencia de los arreglos en otros lenguajes, los arreglos en Rust tienen una longitud fija.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3];
    println!(&quot;El primer valor del arreglo es: {}&quot;, a[0]);
    println!(&quot;El segundo valor del arreglo es: {}&quot;, a[1]);
    println!(&quot;El tercer valor del arreglo es: {}&quot;, a[2]);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funciones"><a class="header" href="#funciones">Funciones</a></h1>
<p>La función main, es el punto de entrada de toda la ejecución del programa. La palabra clave fn permite declarar nuevas funciones y el cuerpo de la función se define dentro de corchetes {}.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hola, Mundo!&quot;);

    mi_funcion();
}

fn mi_funcion() {
    println!(&quot;Esta es mi función.&quot;);
}
</code></pre></pre>
<h3 id="parámetros"><a class="header" href="#parámetros">Parámetros</a></h3>
<p>Para definir funciones que tienen parámetros, se debe seguir esta estructura:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hola, Mundo!&quot;);

    mi_funcion(11,'p');
}

fn mi_funcion(x: i32, caracter: char) {
    println!(&quot;El valor de x es: {} y el caracter es {}&quot;, x,caracter);
}
</code></pre></pre>
<h3 id="retornando-valores"><a class="header" href="#retornando-valores">Retornando valores</a></h3>
<p>No es necesario especificar el retorno dentro del cuerpo de la función, pero si se denota con una flecha -&gt; en la declaración, luego de indicar los parámetros.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = suma_dos(7);

    println!(&quot;El valor de x es: {}&quot;, x);
}

fn suma_dos(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comentarios"><a class="header" href="#comentarios">Comentarios</a></h1>
<p>Para aquellos casos en los que necesites agregar comentarios a tu código, puedes hacerlo de la siguiente manera:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Aqui hay un comentario de una línea&quot;) // Comentario :D
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Aqui hay un comentario multilínea&quot;) /* Comentario Multilínea :D
( ͡° ͜ʖ ͡°)
~(^-^)~
*/
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estructuras"><a class="header" href="#estructuras">Estructuras</a></h1>
<p>Un struct, o estructura, es un tipo de datos personalizado que permite empaquetar y nombrar múltiples valores relacionados que conforman un grupo significativo. Si estás familiarizado con un lenguaje orientado a objetos, una estructura es como los atributos de datos de un objeto. </p>
<p>Es un objeto que carece de métodos.</p>
<h1 id="definición-de-una-estructura"><a class="header" href="#definición-de-una-estructura">Definición de una estructura</a></h1>
<p>Usamos la palabra clave <strong>struct</strong> seguido de un nombre para la estructura, debe ser un nombre descriptivo que defina perfectamente los que a almacenar. Después entre llaves, se definirán los nombres y tipos de los datos que la conformarán que serán lo que llamamos campos.<br />
<img src="tutorial/../images/def_struct.png" alt="def_struct.png" /></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">   active: bool,
</span><span class="boring">   username: String,
</span><span class="boring">   email: String,
</span><span class="boring">   sign_in_count: u64,
</span><span class="boring">}
</span>let primer_usuario = User {
    username: String::from(&quot;bdleons&quot;),
    email: String::from(&quot;bdleons@gmail.com&quot;),
    active: true,
    sign_in_count: 1,
};

println!(&quot;Nombre de Usuario: {}&quot;, primer_usuario.username);
println!(&quot;Email de Usuario: {}&quot;, primer_usuario.email);
println!(&quot;Usuario activo?: {}&quot;, primer_usuario.active);
println!(&quot;Count: {}&quot;, primer_usuario.sign_in_count);

<span class="boring">}
</span></code></pre></pre>
<p>Si una instancia es mutable, toda la estructura sera mutable</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">   active: bool,
</span><span class="boring">   username: String,
</span><span class="boring">   email: String,
</span><span class="boring">   sign_in_count: u64,
</span><span class="boring">}
</span>let mut segundo_usuario = User {
    username: String::from(&quot;elpepe&quot;),
    email: String::from(&quot;alejandro007@gmail.com&quot;),
    active: true,
    sign_in_count: 1,
};

println!(&quot;Nombre de Usuario: {}&quot;, segundo_usuario.username);
println!(&quot;Email de Usuario: {}&quot;, segundo_usuario.email);
println!(&quot;Usuario activo?: {}&quot;, segundo_usuario.active);
println!(&quot;Count: {}&quot;, segundo_usuario.sign_in_count);

println!(&quot;&quot;);
segundo_usuario.username = String::from(&quot;alejadroS&quot;);
segundo_usuario.email = String::from(&quot;alejadroSoler@hotmail.com&quot;);
segundo_usuario.active = false;
segundo_usuario.sign_in_count = 2;

println!(&quot;Nombre de Usuario: {}&quot;, segundo_usuario.username);
println!(&quot;Email de Usuario: {}&quot;, segundo_usuario.email);
println!(&quot;Usuario activo?: {}&quot;, segundo_usuario.active);
println!(&quot;Count: {}&quot;, segundo_usuario.sign_in_count);
<span class="boring">}
</span></code></pre></pre>
<p>Las funciones pueden retornar estructuras.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">   active: bool,
</span><span class="boring">   username: String,
</span><span class="boring">   email: String,
</span><span class="boring">   sign_in_count: u64,
</span><span class="boring">}
</span>fn nuevo_usuario(username: String, email: String) -&gt; User {
    User {
        username: username,
        email: email,
        active: true,
        sign_in_count: 0,
    }
}

let tercer_usuario = nuevo_usuario(String::from(&quot;chpetilotag&quot;),String::from(&quot;petilota_mail@gmail.com&quot;));
println!(&quot;Nombre de Usuario: {}&quot;, tercer_usuario.username);
println!(&quot;Email de Usuario: {}&quot;, tercer_usuario.email);
println!(&quot;Usuario activo?: {}&quot;, tercer_usuario.active);
println!(&quot;Count: {}&quot;, tercer_usuario.sign_in_count);
<span class="boring">}
</span></code></pre></pre>
<p>Podemos tomar información contenida en estructuras ya instanciadas para usarla en la instanciación de nuevas.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">   active: bool,
</span><span class="boring">   username: String,
</span><span class="boring">   email: String,
</span><span class="boring">   sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">let primer_usuario = User {
</span><span class="boring">   username: String::from(&quot;bdleons&quot;),
</span><span class="boring">   email: String::from(&quot;bdleons@gmail.com&quot;),
</span><span class="boring">   active: true,
</span><span class="boring">   sign_in_count: 1,
</span><span class="boring">};
</span>let mut cuarto_usuario = User {
    username: String::from(&quot;otronombre&quot;),
    email: String::from(&quot;otronombre@gmail.com&quot;),
    active: primer_usuario.active,
    sign_in_count: primer_usuario.sign_in_count,
};
println!(&quot;Nombre de Usuario: {}&quot;, cuarto_usuario.username);
println!(&quot;Email de Usuario: {}&quot;, cuarto_usuario.email);
println!(&quot;Usuario activo?: {}&quot;, cuarto_usuario.active);
println!(&quot;Count: {}&quot;, cuarto_usuario.sign_in_count);
<span class="boring">}
</span></code></pre></pre>
<p>Rust nos da una abreviatura para facilitar esto.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">   active: bool,
</span><span class="boring">   username: String,
</span><span class="boring">   email: String,
</span><span class="boring">   sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">let mut segundo_usuario = User {
</span><span class="boring">   username: String::from(&quot;elpepe&quot;),
</span><span class="boring">   email: String::from(&quot;alejandro007@gmail.com&quot;),
</span><span class="boring">   active: true,
</span><span class="boring">   sign_in_count: 1,
</span><span class="boring">};
</span><span class="boring">segundo_usuario.username = String::from(&quot;alejadroS&quot;);
</span><span class="boring">segundo_usuario.email = String::from(&quot;alejadroSoler@hotmail.com&quot;);
</span><span class="boring">segundo_usuario.active = false;
</span><span class="boring">segundo_usuario.sign_in_count = 2;
</span>let mut quinto_usuario = User {
    username: String::from(&quot;anonimo&quot;),
    email: String::from(&quot;anonimous007@gmail.com&quot;),
    ..segundo_usuario
};
println!(&quot;Nombre de Usuario: {}&quot;, quinto_usuario.username);
println!(&quot;Email de Usuario: {}&quot;, quinto_usuario.email);
println!(&quot;Usuario activo?: {}&quot;, quinto_usuario.active);
println!(&quot;Count: {}&quot;, quinto_usuario.sign_in_count);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estructuras-de-tupla"><a class="header" href="#estructuras-de-tupla">Estructuras de Tupla</a></h1>
<p>Las estructuras de tupla son un hibrido entre ambos tipos de datos: tiene el significado que proporciona el nombre de la estructura, pero no tienen nombres en sus campos, es decir, solo tienen el nombre del tipo de dato. Son útiles en casos para cuales nombrar cada campo puede ser redundante.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color (u32, u32, u32);
struct Coordenada (i32, i32);

let blanco = Color (255,255,255);
let origen = Coordenada (0,0);

println!(&quot;Color: {}, {}, {}&quot;, blanco.0,blanco.1,blanco.2);
println!(&quot;Punto: {}, {}&quot;, origen.0, origen.1);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estructura-tipo-unidad"><a class="header" href="#estructura-tipo-unidad">Estructura Tipo-Unidad</a></h1>
<p>También puedes definir estructuras que no tengan ningún campo. Se llaman structs unitarios porque se comportan de forma similar a () &quot;Tupla de Tipo Unitaria&quot;. Las estructuras unitarias pueden ser útiles cuando necesitas implementar un rasgo (Trait) en algún tipo pero no tienes ningún dato que quieras almacenar en el propio tipo. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AlwaysEqual;

let subject = AlwaysEqual;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="métodos"><a class="header" href="#métodos">Métodos</a></h1>
<p>Los métodos son similares a las funciones: se declaran con la palabra clave fn y su nombre; pueden tener parámetros y un valor de retorno, y contienen código que se ejecuta cuando se invoca. 
Sin embargo, los métodos son diferentes de las funciones en que se definen dentro del contexto de una estructura (o una enumeración o un objeto de rasgo), y su primer parámetro es siempre self, que representa la instancia de la estructura en la que se está llamando al método.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rectangulo {
    alto: u32,
    ancho: u32,
}

impl Rectangulo {
    fn area(&amp;self) -&gt; u32 {
        self.alto * self.ancho
    }
    
    fn puede_contener(&amp;self, otro: &amp;Rectangulo) -&gt; bool {
        self.alto &gt; otro.alto &amp;&amp; self.ancho &gt; otro.ancho
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Rectangulo {
</span><span class="boring">   alto: u32,
</span><span class="boring">   ancho: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangulo {
</span><span class="boring">   fn area(&amp;self) -&gt; u32 {
</span><span class="boring">       self.alto * self.ancho
</span><span class="boring">   }
</span><span class="boring">   
</span><span class="boring">   fn puede_contener(&amp;self, otro: &amp;Rectangulo) -&gt; bool {
</span><span class="boring">       self.alto &gt; otro.alto &amp;&amp; self.ancho &gt; otro.ancho
</span><span class="boring">   }
</span><span class="boring">}
</span>let rectangulo_uno = Rectangulo {
    alto: 50,
    ancho: 35,
};
println!(&quot;Area del rentangulo: {}&quot;, rectangulo_uno.area());

let rectangulo_dos = Rectangulo {
    alto: 60,
    ancho: 40,
};
println!(&quot;Puede 2 contener a 1: {}&quot;, rectangulo_dos.puede_contener(&amp;rectangulo_uno));
println!(&quot;Puede 1 contener a 2: {}&quot;, rectangulo_uno.puede_contener(&amp;rectangulo_dos));
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funciones-asociadas"><a class="header" href="#funciones-asociadas">Funciones asociadas</a></h1>
<p>Podemos definir funciones dentro de los bloques impl que no toman como parámetro a self. Estas se denominan funciones asociadas porque están asociadas con la estructura. Siguen siendo funciones, no métodos, porque no tienen una instancia de la estructura con la que trabajar.
Las funciones asociadas se utilizan a menudo para constructores que devolverán una nueva instancia de la estructura.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Rectangulo {
</span><span class="boring">   alto: u32,
</span><span class="boring">   ancho: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangulo {
</span><span class="boring">   fn area(&amp;self) -&gt; u32 {
</span><span class="boring">       self.alto * self.ancho
</span><span class="boring">   }
</span><span class="boring">   
</span><span class="boring">   fn puede_contener(&amp;self, otro: &amp;Rectangulo) -&gt; bool {
</span><span class="boring">       self.alto &gt; otro.alto &amp;&amp; self.ancho &gt; otro.ancho
</span><span class="boring">   }
</span><span class="boring">}
</span>impl Rectangulo {
    fn cuadrado(lado: u32) -&gt; Rectangulo {
        Rectangulo {
            alto: lado,
            ancho: lado,
        }
    }
}
let cuadrado_uno = Rectangulo::cuadrado(10);
println!(&quot;Area del cuadrado: {}&quot;, cuadrado_uno.area());
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumeraciones"><a class="header" href="#enumeraciones">Enumeraciones</a></h1>
<p>Las enumeraciones permiten definir un tipo enumerando sus posibles variantes, de ahí su nombre. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Mensaje {
    Salir, //Estructura unitaria
    CambiarColor(i32, i32, i32), //Estructura de Tupla
    Mover { x: i32, y: i32 }, //Estructura
    Escribir(String), //Estructura de Tupla
}

let w: Mensaje = Mensaje::Escribir(String::from(&quot;Hola Mundo!&quot;));
let x: Mensaje = Mensaje::Mover { x: 3, y: 4 };
<span class="boring">}
</span></code></pre></pre>
<p>Utilizamos la sintaxis :: para hacer uso de cada variante: las variantes están dentro del ámbito del enum. Lo que hace que lo siguiente sea valido:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Mensaje {
</span><span class="boring">   Salir, //Estructura unitaria
</span><span class="boring">   CambiarColor(i32, i32, i32), //Estructura de Tupla
</span><span class="boring">   Mover { x: i32, y: i32 }, //Estructura
</span><span class="boring">   Escribir(String), //Estructura de Tupla
</span><span class="boring">}
</span>enum TurnoJuegoMesa {
    Mover { celdas: i32 }, //Estructura
    Pasar, //Estructura unitaria
}
let y: TurnoJuegoMesa = TurnoJuegoMesa::Mover { celdas: 1 };
let z: Mensaje = Mensaje::Mover { x: 3, y: 4 };
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-rasgos"><a class="header" href="#traits-rasgos">Traits (Rasgos)</a></h1>
<p>Un trait indica al compilador una funcionalidad que tendrá un tipo en particular y que puede compartir con otros tipos. Podemos usar traits para definir el comportamiento compartido de una manera abstracta. Incluso, podemos usar trait para especificar que un tipo genérico puede ser cualquier tipo que tenga cierto comportamiento.</p>
<p>Los rasgos son similares a una característica que suele llamarse interfaces en otros lenguajes, aunque con algunas diferencias.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait TieneArea {
    fn area(&amp;self) -&gt; f64; //Un funcion sin definir
}

struct Circulo {
    x: f64,
    y: f64,
    radio: f64,
}

impl TieneArea for Circulo {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radio * self.radio) //redifinicion de area para circulo
    }
}

struct Cuadrado {
    x: f64,
    y: f64,
    lado: f64,
}

impl TieneArea for Cuadrado {
    fn area(&amp;self) -&gt; f64 {
        self.lado * self.lado //redifinicion de area para cuadrado
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Los traits son útiles porque permiten a un tipo hacer ciertas promesas acerca de su comportamiento. La funciones genéricas pueden explotar esto para restringir los tipos que aceptan. Considera esta función, la cual no compila:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait TieneArea {
</span><span class="boring">   fn area(&amp;self) -&gt; f64; //Un funcion sin definir
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Circulo {
</span><span class="boring">   x: f64,
</span><span class="boring">   y: f64,
</span><span class="boring">   radio: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TieneArea for Circulo {
</span><span class="boring">   fn area(&amp;self) -&gt; f64 {
</span><span class="boring">       std::f64::consts::PI * (self.radio * self.radio) //redifinicion de area para circulo
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Cuadrado {
</span><span class="boring">   x: f64,
</span><span class="boring">   y: f64,
</span><span class="boring">   lado: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TieneArea for Cuadrado {
</span><span class="boring">   fn area(&amp;self) -&gt; f64 {
</span><span class="boring">       self.lado * self.lado //redifinicion de area para cuadrado
</span><span class="boring">   }
</span><span class="boring">}
</span>
fn imprimir_area&lt;T&gt;(figura: T) {
    println!(&quot;Esta figura tiene un area de {}&quot;, figura.area());
}
<span class="boring">}
</span></code></pre></pre>
<p>La sintaxis &lt;T: TieneArea&gt; se traduce en “cualquier tipo que implemente el trait TieneArea.”. A consecuencia de que los traits definen firmas de tipos de función, podemos estar seguros que cualquier tipo que implemente TieneArea tendrá un método .area().</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait TieneArea {
</span><span class="boring">   fn area(&amp;self) -&gt; f64; //Un funcion sin definir
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Circulo {
</span><span class="boring">   x: f64,
</span><span class="boring">   y: f64,
</span><span class="boring">   radio: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TieneArea for Circulo {
</span><span class="boring">   fn area(&amp;self) -&gt; f64 {
</span><span class="boring">       std::f64::consts::PI * (self.radio * self.radio) //redifinicion de area para circulo
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Cuadrado {
</span><span class="boring">   x: f64,
</span><span class="boring">   y: f64,
</span><span class="boring">   lado: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TieneArea for Cuadrado {
</span><span class="boring">   fn area(&amp;self) -&gt; f64 {
</span><span class="boring">       self.lado * self.lado //redifinicion de area para cuadrado
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">fn imprimir_area&lt;T: TieneArea&gt;(figura: T) {
</span><span class="boring">   println!(&quot;Esta figura tiene un area de {}&quot;, figura.area());
</span><span class="boring">}
</span>let c = Circulo {
    x: 0.0f64,
    y: 0.0f64,
    radio: 1.0f64,
};

let s = Cuadrado {
    x: 0.0f64,
    y: 0.0f64,
    lado: 1.0f64,
};

imprimir_area(c);
imprimir_area(s);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrencia-1"><a class="header" href="#concurrencia-1">Concurrencia</a></h1>
<h3 id="hilos"><a class="header" href="#hilos">Hilos</a></h3>
<p>Ejecutan simultáneamente partes independientes de un programa.</p>
<h4 id="creando-un-hilo"><a class="header" href="#creando-un-hilo">Creando un hilo</a></h4>
<ol>
<li>Se importan las funciones relacionadas con hilos de <code>std::thread</code> con <code>use</code>. </li>
</ol>
<pre><code class="language-rust noplayground">use std::thread;
</code></pre>
<ol start="2">
<li>Para crear un hilo se usa <code>thread::spawn</code> que recibe una <em>closure</em> como argumento y retorna un <em>JoinHandler</em>.</li>
</ol>
<pre><code class="language-rust noplayground">thread::spawn(|| { /* Código que se ejecutará en el hilo */ });
</code></pre>
<h4 id="creando-un-hilo---ejemplo-1"><a class="header" href="#creando-un-hilo---ejemplo-1">Creando un hilo - <em>Ejemplo 1</em></a></h4>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

fn main() {
    thread::spawn(|| {
        println!(&quot;Hola desde un nuevo hilo!&quot;);
    });
}
</code></pre></pre>
<h4 id="creando-un-hilo---ejemplo-2"><a class="header" href="#creando-un-hilo---ejemplo-2">Creando un hilo - <em>Ejemplo 2</em></a></h4>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Hola {} desde el nuevo hilo!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Hola {} desde el hilo principal!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>El nuevo hilo se detendrá cuando finalice el hilo principal.</p>
<p>Las llamadas a thread::sleep obligan a un hilo a detener su ejecución durante un breve período, lo que permite que se ejecute un hilo diferente.</p>
<h4 id="join-handles"><a class="header" href="#join-handles">Join handles</a></h4>
<p>Para esperar a que todos los hilos terminen su ejecución, podemos usar el método <code>join</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

fn main() {
    let child = thread::spawn(|| {
        println!(&quot;Hola desde un hilo!&quot;);
    });
    let _ = child.join();
}
</code></pre></pre>
<h4 id="join-handle---ejemplo-2"><a class="header" href="#join-handle---ejemplo-2">Join handle - <em>Ejemplo 2</em></a></h4>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Hola {} desde el nuevo hilo!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;Hola {} desde el hilo principal!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<h4 id="move-closure"><a class="header" href="#move-closure"><code>move</code> closure</a></h4>
<p>Permite usar datos en un hilo en otro hilo.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p>Si queremos forzar el closure para que se apropie de los valores que usa en el entorno, podemos usar <code>move</code> antes de la lista de parámetros.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paso-de-mensajes-entre-hilos"><a class="header" href="#paso-de-mensajes-entre-hilos"><strong>Paso de mensajes entre hilos</strong></a></h1>
<p>En Rust existe el concepto de <em>channel</em> para el paso de mensajes en programación concurrente. Este es como si fuera un caudal de agua, donde lo que se ponga en él va a correr en el sentido que vaya el agua.</p>
<p>Este canal tiene dos partes: un transmisor y un receptor. El transmisor es por medio del cual se envia la información y el receptor es donde llega esa información.</p>
<h3 id="como-se-declara-un-canal-en-rust"><a class="header" href="#como-se-declara-un-canal-en-rust">¿Como se declara un canal en Rust?</a></h3>
<p><code>let (tx, rx) = mpsc::channel();</code></p>
<p>En este caso <em><strong>tx</strong></em> va a ser el transmisor del canal y <em><strong>rx</strong></em> va a ser el receptor.</p>
<h2 id="ejemplo-basico"><a class="header" href="#ejemplo-basico">Ejemplo Basico</a></h2>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
fn main (){
    let (tx, rx) = mpsc::channel();
    let valor = &quot;$100.000&quot;;

    thread::spawn(move || {
        let precio = String::from(valor);
        println!(&quot;Precio: {}&quot;, precio);
        tx.send(precio).unwrap();
        //println!(&quot;Precio: {}&quot;, precio);
    });

    let received = rx.recv().unwrap();
    println!(&quot;El precio del producto es: {}&quot;, received);
}
</code></pre></pre>
<h2 id="ejemplo-basico---parte2"><a class="header" href="#ejemplo-basico---parte2">Ejemplo Basico - Parte2</a></h2>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;

fn main (){
    let (tx, rx) = mpsc::channel();

    let precio = 100000;

    println!(&quot;El precio del producto es: ${}.&quot;, precio);

    thread::spawn(move || {
        let bono = 10000;
        let valor = precio - bono;
        tx.send(valor).unwrap();
        println!(&quot;Bono de ${} aplicado.&quot;, bono);
    });

    let total = rx.recv().unwrap();

    println!(&quot;El precio total es: ${}.&quot;, total);
}

</code></pre></pre>
<h2 id="ejemplo-enviando-2-variables"><a class="header" href="#ejemplo-enviando-2-variables">Ejemplo Enviando 2 Variables</a></h2>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main(){
    let (tx, rx) = mpsc::channel();

    let precio = 100000;

    println!(&quot;El precio del producto es: ${}.&quot;, precio);

    thread::spawn(move || {
        let bono = 10000;
        let valor = precio - bono;
        tx.send(bono).unwrap();
        //thread::sleep(Duration::from_secs(1));
        tx.send(valor).unwrap();
    });

    for receptor in rx {
        println!(&quot;${}&quot;, receptor);
    }
}

</code></pre></pre>
<h2 id="ejemplo-enviando-2-variables-de-diferentes-hilos"><a class="header" href="#ejemplo-enviando-2-variables-de-diferentes-hilos">Ejemplo Enviando 2 Variables de Diferentes Hilos</a></h2>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
use std::time::Duration;
fn main(){
    let (tx, rx) = mpsc::channel();

    let precio = 100000;

    println!(&quot;El precio del producto es: ${}.&quot;, precio);

    let tx1 = tx.clone();
    thread::spawn(move || {
        let iva = 19000;
        tx1.send(iva).unwrap();
        //thread::sleep(Duration::from_secs(1));
    });

    thread::spawn(move || {
        let bono = 10000;
        let valor = precio + 19000 - bono;
        tx.send(bono).unwrap();
        //thread::sleep(Duration::from_secs(1));
        tx.send(valor).unwrap();
    });

    for receptor in rx {
        println!(&quot;${}&quot;, receptor);
    }    
}
</code></pre></pre>
<h2 id="ejemplo-enviando-variables-entre-nuevos-hilos"><a class="header" href="#ejemplo-enviando-variables-entre-nuevos-hilos">Ejemplo Enviando Variables Entre Nuevos Hilos</a></h2>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
use std::time::Duration;
fn main(){
    let (tx, rx) = mpsc::channel();
    let (tx2, rx2) = mpsc::channel();

    let precio = 100000;

    println!(&quot;El precio del producto es: ${}.&quot;, precio);

    thread::spawn(move || {
        let iva = 19000;
        tx2.send(iva).unwrap();
        //thread::sleep(Duration::from_secs(1));
    });

    thread::spawn(move || {
        let bono = 10000;
        let impuesto = rx2.recv().unwrap();
        let valor = precio + impuesto - bono;
        tx.send(impuesto).unwrap();
        tx.send(bono).unwrap();
        //thread::sleep(Duration::from_secs(1));
        tx.send(valor).unwrap();
    });

    for receptor in rx {
        println!(&quot;${}&quot;, receptor);
    }    
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencias"><a class="header" href="#referencias">Referencias</a></h1>
<p>Los contenidos desarollados en este libro están basados en los contenidos de los siguientes recursos dígitales: </p>
<ul>
<li><a href="https://www.rust-lang.org/">Página oficial de Rust</a></li>
<li><a href="https://doc.rust-lang.org/book/">Libro de Rust</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rust_(programming_language)">Rust - Wikipedia</a></li>
<li><a href="https://rust-lang.github.io/mdBook/">MDBook</a></li>
</ul>
<p>Adicionalmente, recomendamos los siguientes recursos para un mayor entendimiento y profundización de los conceptos abordados en el tutorial:</p>
<ul>
<li><a href="https://www.amazon.com/gp/product/1718500440/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1718500440&amp;linkCode=as2&amp;tag=booksoncode-20&amp;linkId=69315490f3fdb6f519f6ac1eec03af09">The Rust Programming Language</a></li>
<li><a href="https://www.amazon.com/gp/product/1617294551/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1617294551&amp;linkCode=as2&amp;tag=booksoncode-20&amp;linkId=ffa705351a870f2b11aa36b0ebaa223a">Rust in Action</a></li>
<li><a href="https://www.amazon.com/gp/product/1492052590/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1492052590&amp;linkCode=as2&amp;tag=booksoncode-20&amp;linkId=281f90da3b9a244a5862c4b0819141b2">Programming Rust: Fast, Safe Systems Development</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
